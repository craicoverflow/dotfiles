#!/usr/bin/env bash

set -euo pipefail

# Default search path
SEARCH_PATH="$HOME/code"

# Cache configuration
CACHE_DIR="$HOME/.cache"
CACHE_FILE="$CACHE_DIR/git-switch-project"

# Parse arguments
REMOTE_FLAG=""
PROJECT_FILTER=""
FLUSH_CACHE=false

while [[ $# -gt 0 ]]; do
  case $1 in
    -r)
      REMOTE_FLAG="-r"
      shift
      ;;
    --flush-cache)
      FLUSH_CACHE=true
      shift
      ;;
    *)
      PROJECT_FILTER="$1"
      shift
      ;;
  esac
done

# Create cache directory if it doesn't exist
ensure_cache_dir() {
  [[ ! -d "$CACHE_DIR" ]] && mkdir -p "$CACHE_DIR"
}

# Build project list from filesystem
build_project_list() {
  # Find all .git directories first, then get their parent directories
  find "$SEARCH_PATH" -type d -name ".git" -prune -exec dirname {} \;
}

# Get projects from cache or build new list
find_projects() {
  ensure_cache_dir
  
  # If flush cache flag is set, remove cache file
  if [[ "$FLUSH_CACHE" == true ]]; then
    [[ -f "$CACHE_FILE" ]] && rm "$CACHE_FILE"
    echo "Cache flushed." >&2
  fi
  
  # Check if cache exists and use it, otherwise build and cache
  if [[ -f "$CACHE_FILE" ]]; then
    cat "$CACHE_FILE"
  else
    echo "Building project cache..." >&2
    project_list=$(build_project_list)
    echo "$project_list" > "$CACHE_FILE"
    echo "$project_list"
  fi
}

# Get the editor command
get_editor_cmd() {
  if [[ -n "${CODE_EDITOR:-}" ]]; then
    echo "$CODE_EDITOR"
  else
    echo "${EDITOR:-vim}"
  fi
}

# Main logic
projects=$(find_projects)

# Function to clean paths for display
clean_path() {
  sed "s|^$SEARCH_PATH/||"
}

if [[ -n "$PROJECT_FILTER" ]]; then
  # Filter projects based on input argument
  filtered_projects=$(echo "$projects" | grep -i "$PROJECT_FILTER" || true)
  
  # Count matching projects
  match_count=$(echo "$filtered_projects" | grep -v "^$" | wc -l)
  
  if [[ $match_count -eq 0 ]]; then
    echo "No Git projects found matching: $PROJECT_FILTER"
    exit 1
  elif [[ $match_count -eq 1 ]]; then
    selected_project="$filtered_projects"
  else
    # Multiple matches, use fzf with initial query
    # Create arrays for clean and full paths
    mapfile -t full_paths_array < <(echo "$filtered_projects")
    mapfile -t clean_paths_array < <(echo "$filtered_projects" | clean_path)
    
    # Show clean paths in fzf but track the selection
    selected_clean_path=$(printf '%s\n' "${clean_paths_array[@]}" | fzf --query="$PROJECT_FILTER")
    
    if [[ -n "$selected_clean_path" ]]; then
      # Find the index of the selected clean path and get the corresponding full path
      for i in "${!clean_paths_array[@]}"; do
        if [[ "${clean_paths_array[$i]}" == "$selected_clean_path" ]]; then
          selected_project="${full_paths_array[$i]}"
          break
        fi
      done
      
      # Fallback if not found in array (shouldn't happen but safety check)
      if [[ -z "$selected_project" ]]; then
        selected_project="$SEARCH_PATH/$selected_clean_path"
      fi
    else
      selected_project=""
    fi
  fi
else
  # No filter provided, show all projects in fzf
  # Create arrays for clean and full paths
  mapfile -t full_paths_array < <(echo "$projects")
  mapfile -t clean_paths_array < <(echo "$projects" | clean_path)
  
  # Show clean paths in fzf but track the selection
  selected_clean_path=$(printf '%s\n' "${clean_paths_array[@]}" | fzf)
  
  if [[ -n "$selected_clean_path" ]]; then
    # Find the index of the selected clean path and get the corresponding full path
    for i in "${!clean_paths_array[@]}"; do
      if [[ "${clean_paths_array[$i]}" == "$selected_clean_path" ]]; then
        selected_project="${full_paths_array[$i]}"
        break
      fi
    done
    
    # Fallback if not found in array (shouldn't happen but safety check)
    if [[ -z "$selected_project" ]]; then
      selected_project="$SEARCH_PATH/$selected_clean_path"
    fi
  else
    selected_project=""
  fi
fi

# Exit if no project was selected (user pressed ESC in fzf)
[[ -z "$selected_project" ]] && exit 0

# Change to the selected directory
cd "$selected_project"

# Open in editor if it exists
editor_cmd=$(get_editor_cmd)
if [[ -n "$editor_cmd" ]]; then
  if [[ -n "$REMOTE_FLAG" ]]; then
    $editor_cmd . "$REMOTE_FLAG"
  else
    $editor_cmd .
  fi
fi

