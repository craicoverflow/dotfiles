# Basic git aliases
alias gco='git checkout'
alias gc='git commit'

# Robust rebase from main/master - checks upstream first, then origin
gum() {
  local current_branch remote main_branch stash_created=false
  
  # Get current branch
  current_branch=$(git branch --show-current 2>/dev/null)
  if [[ -z "$current_branch" ]]; then
    echo "‚ùå Error: Not on a branch (detached HEAD?)"
    return 1
  fi
  
  # If already on main/master, do a git pull instead
  if [[ "$current_branch" == "main" || "$current_branch" == "master" ]]; then
    echo "üìç You're on $current_branch. Pulling latest changes instead of rebasing..."
    
    # Determine remote (same logic as below)
    if git remote | grep -q "^upstream$"; then
      remote="upstream"
      echo "üîç Using upstream remote"
    elif git remote | grep -q "^origin$"; then
      remote="origin"
      echo "üîç Using origin remote"
    else
      echo "‚ùå No upstream or origin remote found"
      return 1
    fi
    
    echo "üîÑ Pulling from $remote/$current_branch..."
    if git pull "$remote" "$current_branch"; then
      echo "‚úÖ Successfully updated $current_branch"
    else
      echo "‚ùå Failed to pull from $remote/$current_branch"
      return 1
    fi
    return 0
  fi
  
  # Check for uncommitted changes and offer to stash
  if ! git diff-index --quiet HEAD -- 2>/dev/null; then
    echo "‚ö†Ô∏è  You have uncommitted changes."
    echo -n "Stash them and continue? [y/N]: "
    read -r stash_confirm
    if [[ "$stash_confirm" == "y" || "$stash_confirm" == "Y" ]]; then
      git stash push -m "grbm auto-stash $(date '+%Y-%m-%d %H:%M:%S')" || {
        echo "‚ùå Failed to stash changes"
        return 1
      }
      stash_created=true
      echo "‚úÖ Changes stashed"
    else
      echo "‚ùå Aborting due to uncommitted changes"
      return 1
    fi
  fi
  
  # Function to cleanup on exit
  cleanup_on_error() {
    if [[ "$stash_created" == "true" ]]; then
      echo "üîÑ Restoring stashed changes..."
      git stash pop
    fi
  }
  
  # Set trap for cleanup
  trap cleanup_on_error ERR
  
  # Determine remote priority: upstream first, then origin
  if git remote | grep -q "^upstream$"; then
    remote="upstream"
    echo "üîç Using upstream remote"
  elif git remote | grep -q "^origin$"; then
    remote="origin"
    echo "üîç Using origin remote"
  else
    echo "‚ùå No upstream or origin remote found"
    cleanup_on_error
    return 1
  fi
  
  # Determine main branch (main or master)
  echo "üîÑ Fetching from $remote..."
  git fetch --prune "$remote" || {
    echo "‚ùå Failed to fetch from $remote"
    cleanup_on_error
    return 1
  }
  
  if git ls-remote --heads "$remote" | grep -q "refs/heads/main"; then
    main_branch="main"
  elif git ls-remote --heads "$remote" | grep -q "refs/heads/master"; then
    main_branch="master"
  else
    echo "‚ùå Neither 'main' nor 'master' branch found on $remote"
    cleanup_on_error
    return 1
  fi
  
  echo "üìç Rebasing $current_branch onto $remote/$main_branch"
  
  # Perform the rebase
  if git rebase "$remote/$main_branch"; then
    echo "‚úÖ Successfully rebased $current_branch onto $remote/$main_branch"
    
    # Restore stash if we created one
    if [[ "$stash_created" == "true" ]]; then
      echo "üîÑ Restoring stashed changes..."
      if git stash pop; then
        echo "‚úÖ Stashed changes restored"
      else
        echo "‚ö†Ô∏è  Failed to restore stash - you may need to resolve conflicts"
        echo "üí° Use 'git stash list' and 'git stash pop' manually"
      fi
    fi
    
    # Check if we're ahead and suggest push
    local ahead_count
    ahead_count=$(git rev-list --count HEAD@{upstream}..HEAD 2>/dev/null || echo "0")
    if [[ "$ahead_count" -gt 0 ]]; then
      echo "üí° Your branch is $ahead_count commits ahead. Consider 'git push --force-with-lease'"
    fi
    
  else
    echo "‚ùå Rebase failed - you may have conflicts to resolve"
    echo "üí° After resolving conflicts:"
    echo "   - 'git add <files>' to stage resolved files"
    echo "   - 'git rebase --continue' to continue"
    echo "   - 'git rebase --abort' to abort and return to original state"
    
    # Don't auto-restore stash during conflicts
    if [[ "$stash_created" == "true" ]]; then
      echo "‚ö†Ô∏è  Your changes are still stashed. Use 'git stash pop' after resolving conflicts."
    fi
    
    trap - ERR  # Remove trap since we're handling the error
    return 1
  fi
  
  trap - ERR  # Remove trap on success
}
alias gswm="git switch main || git switch master"
alias gswmf="gswm && grbm"
alias grbc="git rebase --continue"
alias gcam="git commit --amend"
alias gcamne="gcam --no-edit"
alias gpf="git push --force-with-lease"
alias gpff="git push --force"
alias grbi="git rebase -i --autostash"
alias gdelub="git branch --merged | egrep -v \"(^\*|master|main)\" | xargs git branch -d"
alias glog="git log --graph --pretty=format:'%C(yellow)%h%Creset  %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit -10"
alias gcb='git switch -c'

# Interactive aliases
alias gcoi="git-checkout-interactive"
alias cdgr="cd-git-root"

# New powerful aliases
alias gst="git status --short"
alias gss="git-status-interactive"
alias gai="git-add-interactive"
alias gci="git-commit-interactive"
alias gshi="git-stash-interactive"
alias glogi="git-log-interactive"
alias gfhi="git-file-history"
alias gcri="git-conflict-resolver"
alias gpsu="git-push-set-upstream"
alias grau="git-remote-add-upstream"
alias gwip="git-work-in-progress"
alias gunwip="git-unwip"
alias gclean="git-clean-interactive"
alias gtag="git-tag-interactive"
alias gundo="git-undo-last-commit"
alias gfixup="git-fixup-interactive"

# Script shortcuts
alias gwt="git-worktree-manager"
alias gba="git-branch-analyzer"
alias grel="git-release-helper"
alias ginit="git-repo-init"
alias gsp="git switch-project"

# GitHub CLI
alias ghprv="gh pr view --web"
alias ghprc="gh pr create"

# interactively switch branch using fzf
git-checkout-interactive() {
  git checkout $(git for-each-ref refs/heads/ --format='%(refname:short)' | fzf)
}

# cd to the root of this Git project
cd-git-root() {
  cd "$(git rev-parse --show-toplevel 2>/dev/null)"
}

git-delete-merged-branches() {
  current_branch=$(git branch --show-current)
  git checkout main || git checkout main
  git pull origin main || git pull origin master
  git branch --merged | egrep -v '\\*\\|master\\|main' | xargs -n 1 -r git branch -d
  git checkout $current_branch
}
alias gdelmb='git-delete-merged-branches'

# Interactive git status with actions
git-status-interactive() {
  local file
  file=$(git status --porcelain | fzf --preview 'git diff --color=always {2}' --preview-window=right:60% | awk '{print $2}')
  if [[ -n "$file" ]]; then
    echo "Selected: $file"
    echo "Actions: [a]dd, [d]iff, [c]heckout, [r]eset, [e]dit"
    read -r action
    case $action in
      a) git add "$file" ;;
      d) git diff "$file" ;;
      c) git checkout "$file" ;;
      r) git reset HEAD "$file" ;;
      e) $EDITOR "$file" ;;
    esac
  fi
}

# Interactive file adding with preview
git-add-interactive() {
  git diff --name-only | fzf -m --preview 'git diff --color=always {}' --preview-window=right:60% | xargs -r git add
}

# Interactive commit with template
git-commit-interactive() {
  local type
  type=$(echo -e "feat\nfix\nrefactor\ntest\ndocs\nstyle\nchore" | fzf --prompt="Commit type: ")
  if [[ -n "$type" ]]; then
    echo -n "Scope (optional): "
    read -r scope
    echo -n "Description: "
    read -r desc
    
    local message="$type"
    [[ -n "$scope" ]] && message="$message($scope)"
    message="$message: $desc"
    
    git commit -m "$message"
  fi
}

# Interactive stash management
git-stash-interactive() {
  local action
  action=$(echo -e "save\nlist\npop\napply\ndrop\nshow" | fzf --prompt="Stash action: ")
  
  case $action in
    save)
      echo -n "Stash message: "
      read -r message
      git stash save "$message"
      ;;
    list)
      git stash list
      ;;
    pop|apply|drop|show)
      local stash
      stash=$(git stash list | fzf | cut -d: -f1)
      [[ -n "$stash" ]] && git stash "$action" "$stash"
      ;;
  esac
}

# Interactive log viewer
git-log-interactive() {
  git log --oneline --color=always | fzf --ansi --preview 'git show --color=always {1}' --preview-window=right:60%
}

# View file history interactively
git-file-history() {
  local file
  file=$(find . -type f -not -path './.git/*' | fzf --prompt="Select file: ")
  if [[ -n "$file" ]]; then
    git log --oneline --color=always -- "$file" | fzf --ansi --preview "git show --color=always {1} -- $file" --preview-window=right:60%
  fi
}

# Quick conflict resolver
git-conflict-resolver() {
  local conflicts
  conflicts=$(git diff --name-only --diff-filter=U)
  if [[ -z "$conflicts" ]]; then
    echo "No conflicts found"
    return
  fi
  
  echo "$conflicts" | fzf -m --prompt="Select conflicts to resolve: " | while read -r file; do
    echo "Opening $file for conflict resolution..."
    $EDITOR "$file"
    echo "Mark as resolved? [y/N]"
    read -r confirm
    [[ "$confirm" == "y" ]] && git add "$file"
  done
}

# Push and set upstream
git-push-set-upstream() {
  local branch
  branch=$(git branch --show-current)
  git push -u origin "$branch"
}

# Add upstream remote
git-remote-add-upstream() {
  echo -n "Upstream URL: "
  read -r upstream_url
  git remote add upstream "$upstream_url"
  git fetch upstream
}

# Work in progress - quick save
git-work-in-progress() {
  git add -A
  git commit -m "WIP: work in progress [ci skip]"
}

# Undo work in progress
git-unwip() {
  local last_commit
  last_commit=$(git log -1 --pretty=%B)
  if [[ "$last_commit" =~ ^WIP: ]]; then
    git reset HEAD~1
  else
    echo "Last commit is not a WIP commit"
  fi
}

# Interactive clean
git-clean-interactive() {
  git clean -i
}

# Interactive tagging
git-tag-interactive() {
  echo -n "Tag name: "
  read -r tag_name
  echo -n "Tag message: "
  read -r tag_message
  git tag -a "$tag_name" -m "$tag_message"
  echo "Push tag to origin? [y/N]"
  read -r confirm
  [[ "$confirm" == "y" ]] && git push origin "$tag_name"
}

# Undo last commit (keep changes)
git-undo-last-commit() {
  echo "This will undo the last commit but keep your changes."
  echo "Continue? [y/N]"
  read -r confirm
  [[ "$confirm" == "y" ]] && git reset --soft HEAD~1
}

# Interactive fixup
git-fixup-interactive() {
  local commit
  commit=$(git log --oneline | fzf --prompt="Select commit to fixup: " | cut -d' ' -f1)
  if [[ -n "$commit" ]]; then
    git commit --fixup="$commit"
    echo "Run interactive rebase to apply fixup? [y/N]"
    read -r confirm
    [[ "$confirm" == "y" ]] && git rebase -i --autosquash "$commit"~1
  fi
}
